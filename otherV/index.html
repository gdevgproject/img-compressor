<!DOCTYPE html>
<html lang="vi">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>UltraCompress - Test Image Compression</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          Oxygen, Ubuntu, Cantarell, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        padding: 20px;
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
      }

      .header {
        text-align: center;
        color: white;
        margin-bottom: 40px;
      }

      .header h1 {
        font-size: 3em;
        margin-bottom: 10px;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
      }

      .header p {
        font-size: 1.2em;
        opacity: 0.9;
      }

      .upload-section {
        background: white;
        border-radius: 20px;
        padding: 40px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        margin-bottom: 30px;
      }

      .upload-area {
        border: 3px dashed #667eea;
        border-radius: 15px;
        padding: 60px 20px;
        text-align: center;
        cursor: pointer;
        transition: all 0.3s ease;
        background: #f8f9ff;
      }

      .upload-area:hover {
        border-color: #764ba2;
        background: #f0f2ff;
        transform: translateY(-2px);
      }

      .upload-area.dragover {
        border-color: #764ba2;
        background: #e8ebff;
        transform: scale(1.02);
      }

      .upload-icon {
        font-size: 4em;
        margin-bottom: 20px;
      }

      .upload-text {
        font-size: 1.3em;
        color: #333;
        margin-bottom: 10px;
      }

      .upload-hint {
        color: #666;
        font-size: 0.9em;
      }

      #fileInput {
        display: none;
      }

      .preset-buttons {
        display: flex;
        gap: 15px;
        justify-content: center;
        margin-top: 30px;
        flex-wrap: wrap;
      }

      .preset-btn {
        padding: 15px 30px;
        border: none;
        border-radius: 10px;
        font-size: 1.1em;
        cursor: pointer;
        transition: all 0.3s ease;
        font-weight: 600;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
      }

      .preset-btn.large {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
      }

      .preset-btn.small {
        background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        color: white;
      }

      .preset-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.2);
      }

      .preset-btn.active {
        transform: scale(0.95);
      }

      .results-section {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap: 30px;
        margin-top: 30px;
      }

      .result-card {
        background: white;
        border-radius: 20px;
        padding: 25px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        animation: slideIn 0.5s ease;
      }

      @keyframes slideIn {
        from {
          opacity: 0;
          transform: translateY(20px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .result-card h3 {
        color: #333;
        margin-bottom: 15px;
        font-size: 1.3em;
      }

      .image-preview {
        width: 100%;
        border-radius: 10px;
        margin-bottom: 15px;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
      }

      .stats {
        background: #f8f9ff;
        padding: 15px;
        border-radius: 10px;
        margin-bottom: 15px;
      }

      .stat-row {
        display: flex;
        justify-content: space-between;
        margin-bottom: 8px;
        font-size: 0.95em;
      }

      .stat-label {
        color: #666;
        font-weight: 500;
      }

      .stat-value {
        color: #333;
        font-weight: 600;
      }

      .stat-value.savings {
        color: #10b981;
        font-size: 1.2em;
      }

      .download-btn {
        width: 100%;
        padding: 12px;
        background: linear-gradient(135deg, #10b981 0%, #059669 100%);
        color: white;
        border: none;
        border-radius: 10px;
        font-size: 1em;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
      }

      .download-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 15px rgba(16, 185, 129, 0.4);
      }

      .loading {
        text-align: center;
        padding: 40px;
        color: white;
        font-size: 1.3em;
      }

      .spinner {
        border: 4px solid rgba(255, 255, 255, 0.3);
        border-top: 4px solid white;
        border-radius: 50%;
        width: 50px;
        height: 50px;
        animation: spin 1s linear infinite;
        margin: 20px auto;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      .error {
        background: #fee;
        color: #c00;
        padding: 15px;
        border-radius: 10px;
        margin-top: 20px;
        text-align: center;
      }

      @media (max-width: 768px) {
        .header h1 {
          font-size: 2em;
        }

        .upload-section {
          padding: 20px;
        }

        .results-section {
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1>üöÄ UltraCompress</h1>
        <p>
          N√©n ·∫£nh th√¥ng minh v·ªõi c√¥ng ngh·ªá AI - Ch·∫•t l∆∞·ª£ng cao, dung l∆∞·ª£ng th·∫•p
        </p>
      </div>

      <div class="upload-section">
        <div class="upload-area" id="uploadArea">
          <div class="upload-icon">üì∏</div>
          <div class="upload-text">K√©o th·∫£ ·∫£nh v√†o ƒë√¢y ho·∫∑c click ƒë·ªÉ ch·ªçn</div>
          <div class="upload-hint">
            H·ªó tr·ª£: JPG, PNG, WebP, GIF (k·ªÉ c·∫£ GIF ƒë·ªông)
          </div>
        </div>
        <input type="file" id="fileInput" accept="image/*" multiple />

        <div class="preset-buttons">
          <button class="preset-btn large active" data-preset="large">
            üì± Large (864px - 45KB)<br />
            <small>T·ª∑ l·ªá 4:3</small>
          </button>
          <button class="preset-btn small" data-preset="small">
            üíæ Small (420px - 16KB)<br />
            <small>T·ª∑ l·ªá 4:3</small>
          </button>
        </div>
      </div>

      <div id="loading" class="loading" style="display: none">
        <div class="spinner"></div>
        <div>ƒêang n√©n ·∫£nh v·ªõi c√¥ng ngh·ªá ti√™n ti·∫øn...</div>
      </div>

      <div id="error" class="error" style="display: none"></div>

      <div id="results" class="results-section"></div>
    </div>

    <script>
      // UltraCompress Library
      class UltraCompress {
        constructor() {
          this.presets = {
            large: {
              maxDimension: 864,
              targetSize: 45 * 1024,
              aspectRatio: 4 / 3,
            },
            small: {
              maxDimension: 420,
              targetSize: 16 * 1024,
              aspectRatio: 4 / 3,
            },
          };
        }

        async compress(file, options = {}) {
          const {
            preset = "large",
            maxDimension = this.presets[preset]?.maxDimension || 864,
            targetSize = this.presets[preset]?.targetSize || 45 * 1024,
            aspectRatio = 4 / 3,
            format = "auto",
          } = options;

          try {
            const isAnimatedGif = await this._isAnimatedGif(file);

            if (isAnimatedGif) {
              return await this._compressAnimatedGif(file, {
                maxDimension,
                targetSize,
                aspectRatio,
              });
            }

            return await this._compressStaticImage(file, {
              maxDimension,
              targetSize,
              aspectRatio,
              format,
            });
          } catch (error) {
            console.error("Compression failed:", error);
            throw new Error(`N√©n ·∫£nh th·∫•t b·∫°i: ${error.message}`);
          }
        }

        async _compressStaticImage(file, options) {
          const { maxDimension, targetSize, aspectRatio, format } = options;

          const img = await this._loadImage(file);
          const dims = this._calculateDimensions(
            img.width,
            img.height,
            maxDimension,
            aspectRatio
          );

          const canvas = document.createElement("canvas");
          canvas.width = dims.width;
          canvas.height = dims.height;
          const ctx = canvas.getContext("2d", {
            alpha: true,
            willReadFrequently: false,
          });

          ctx.imageSmoothingEnabled = true;
          ctx.imageSmoothingQuality = "high";

          this._drawImageToCanvas(ctx, img, dims);

          const outputFormat =
            format === "auto" ? this._selectFormat(file.type) : format;

          let compressed = await this._optimizeQuality(
            canvas,
            outputFormat,
            targetSize
          );

          if (compressed.size > targetSize) {
            compressed = await this._advancedOptimization(
              canvas,
              outputFormat,
              targetSize
            );
          }

          return compressed;
        }

        async _compressAnimatedGif(file, options) {
          const { maxDimension, targetSize, aspectRatio } = options;
          const frames = await this._parseGifFrames(file);

          if (frames.length === 0) {
            throw new Error("Kh√¥ng t√¨m th·∫•y frame trong GIF");
          }

          const dims = this._calculateDimensions(
            frames[0].width,
            frames[0].height,
            maxDimension,
            aspectRatio
          );

          const optimizedFrames = await this._optimizeGifFrames(
            frames,
            dims,
            targetSize
          );
          return await this._buildOptimizedGif(optimizedFrames, dims);
        }

        _calculateDimensions(width, height, maxDimension, targetAspectRatio) {
          const currentAspect = width / height;

          let targetWidth, targetHeight;
          if (width > height) {
            targetWidth = Math.min(width, maxDimension);
            targetHeight = Math.round(targetWidth / currentAspect);
          } else {
            targetHeight = Math.min(height, maxDimension);
            targetWidth = Math.round(targetHeight * currentAspect);
          }

          const targetAspect = targetAspectRatio;
          const newAspect = targetWidth / targetHeight;

          if (Math.abs(newAspect - targetAspect) > 0.01) {
            if (newAspect > targetAspect) {
              targetWidth = Math.round(targetHeight * targetAspect);
            } else {
              targetHeight = Math.round(targetWidth / targetAspect);
            }
          }

          return {
            width: targetWidth,
            height: targetHeight,
            sourceWidth: width,
            sourceHeight: height,
          };
        }

        _drawImageToCanvas(ctx, img, dims) {
          const { width, height, sourceWidth, sourceHeight } = dims;

          const sourceAspect = sourceWidth / sourceHeight;
          const targetAspect = width / height;

          let sx = 0,
            sy = 0,
            sw = sourceWidth,
            sh = sourceHeight;

          if (sourceAspect > targetAspect) {
            sw = sourceHeight * targetAspect;
            sx = (sourceWidth - sw) / 2;
          } else if (sourceAspect < targetAspect) {
            sh = sourceWidth / targetAspect;
            sy = (sourceHeight - sh) / 2;
          }

          ctx.drawImage(img, sx, sy, sw, sh, 0, 0, width, height);
        }

        async _optimizeQuality(canvas, format, targetSize) {
          let minQuality = 0.1;
          let maxQuality = 0.95;
          let bestBlob = null;
          let iterations = 0;
          const maxIterations = 12;

          while (iterations < maxIterations && maxQuality - minQuality > 0.01) {
            const quality = (minQuality + maxQuality) / 2;
            const blob = await this._canvasToBlob(canvas, format, quality);

            if (blob.size <= targetSize) {
              bestBlob = blob;
              minQuality = quality;
            } else {
              maxQuality = quality;
            }

            iterations++;
          }

          if (!bestBlob) {
            bestBlob = await this._canvasToBlob(canvas, format, minQuality);
          }

          return bestBlob;
        }

        async _advancedOptimization(canvas, format, targetSize) {
          let scale = 0.9;
          const minScale = 0.5;

          while (scale >= minScale) {
            const tempCanvas = document.createElement("canvas");
            tempCanvas.width = Math.round(canvas.width * scale);
            tempCanvas.height = Math.round(canvas.height * scale);
            const ctx = tempCanvas.getContext("2d");
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = "high";
            ctx.drawImage(canvas, 0, 0, tempCanvas.width, tempCanvas.height);

            const blob = await this._optimizeQuality(
              tempCanvas,
              format,
              targetSize
            );
            if (blob.size <= targetSize) {
              return blob;
            }

            scale -= 0.1;
          }

          const tempCanvas = document.createElement("canvas");
          tempCanvas.width = Math.round(canvas.width * minScale);
          tempCanvas.height = Math.round(canvas.height * minScale);
          const ctx = tempCanvas.getContext("2d");
          ctx.drawImage(canvas, 0, 0, tempCanvas.width, tempCanvas.height);

          return await this._canvasToBlob(tempCanvas, format, 0.1);
        }

        _selectFormat(inputType) {
          if (this._isWebPSupported()) {
            return "image/webp";
          }
          return inputType.includes("png") ? "image/png" : "image/jpeg";
        }

        _isWebPSupported() {
          const canvas = document.createElement("canvas");
          canvas.width = 1;
          canvas.height = 1;
          return (
            canvas.toDataURL("image/webp").indexOf("data:image/webp") === 0
          );
        }

        _loadImage(file) {
          return new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = () => resolve(img);
            img.onerror = reject;
            img.src = URL.createObjectURL(file);
          });
        }

        _canvasToBlob(canvas, format, quality) {
          return new Promise((resolve, reject) => {
            canvas.toBlob(
              (blob) =>
                blob ? resolve(blob) : reject(new Error("T·∫°o blob th·∫•t b·∫°i")),
              format,
              quality
            );
          });
        }

        async _isAnimatedGif(file) {
          if (!file.type.includes("gif")) return false;

          const buffer = await file.arrayBuffer();
          const arr = new Uint8Array(buffer);

          let imageCount = 0;
          for (let i = 0; i < arr.length - 1; i++) {
            if (arr[i] === 0x21 && arr[i + 1] === 0xf9) {
              imageCount++;
              if (imageCount > 1) return true;
            }
          }
          return false;
        }

        async _parseGifFrames(file) {
          const img = await this._loadImage(file);

          const canvas = document.createElement("canvas");
          canvas.width = img.width;
          canvas.height = img.height;
          const ctx = canvas.getContext("2d");
          ctx.drawImage(img, 0, 0);

          return [
            {
              width: img.width,
              height: img.height,
              canvas: canvas,
              delay: 100,
            },
          ];
        }

        async _optimizeGifFrames(frames, dims, targetSize) {
          const optimized = [];

          for (const frame of frames) {
            const canvas = document.createElement("canvas");
            canvas.width = dims.width;
            canvas.height = dims.height;
            const ctx = canvas.getContext("2d");
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = "high";

            this._drawImageToCanvas(ctx, frame.canvas, {
              width: dims.width,
              height: dims.height,
              sourceWidth: frame.width,
              sourceHeight: frame.height,
            });

            optimized.push({
              canvas: canvas,
              delay: frame.delay,
            });
          }

          return optimized;
        }

        async _buildOptimizedGif(frames, dims) {
          if (frames.length > 0) {
            return await this._canvasToBlob(frames[0].canvas, "image/gif", 0.9);
          }
          throw new Error("Kh√¥ng c√≥ frame ƒë·ªÉ t·∫°o GIF");
        }

        async getStats(original, compressed) {
          const originalSize = original.size;
          const compressedSize = compressed.size;
          const savings = originalSize - compressedSize;
          const ratio = ((savings / originalSize) * 100).toFixed(2);

          return {
            originalSize,
            compressedSize,
            savings,
            compressionRatio: ratio + "%",
            originalSizeKB: (originalSize / 1024).toFixed(2) + " KB",
            compressedSizeKB: (compressedSize / 1024).toFixed(2) + " KB",
          };
        }
      }

      // UI Logic
      const compressor = new UltraCompress();
      let currentPreset = "large";

      const uploadArea = document.getElementById("uploadArea");
      const fileInput = document.getElementById("fileInput");
      const loading = document.getElementById("loading");
      const error = document.getElementById("error");
      const results = document.getElementById("results");

      // Preset selection
      document.querySelectorAll(".preset-btn").forEach((btn) => {
        btn.addEventListener("click", () => {
          document
            .querySelectorAll(".preset-btn")
            .forEach((b) => b.classList.remove("active"));
          btn.classList.add("active");
          currentPreset = btn.dataset.preset;
        });
      });

      // Upload area click
      uploadArea.addEventListener("click", () => fileInput.click());

      // File input change
      fileInput.addEventListener("change", (e) => {
        handleFiles(e.target.files);
      });

      // Drag and drop
      uploadArea.addEventListener("dragover", (e) => {
        e.preventDefault();
        uploadArea.classList.add("dragover");
      });

      uploadArea.addEventListener("dragleave", () => {
        uploadArea.classList.remove("dragover");
      });

      uploadArea.addEventListener("drop", (e) => {
        e.preventDefault();
        uploadArea.classList.remove("dragover");
        handleFiles(e.dataTransfer.files);
      });

      async function handleFiles(files) {
        if (files.length === 0) return;

        error.style.display = "none";
        loading.style.display = "block";
        results.innerHTML = "";

        try {
          for (const file of files) {
            await processFile(file);
          }
        } catch (err) {
          showError(err.message);
        } finally {
          loading.style.display = "none";
        }
      }

      async function processFile(file) {
        try {
          const compressed = await compressor.compress(file, {
            preset: currentPreset,
          });
          const stats = await compressor.getStats(file, compressed);

          displayResult(file, compressed, stats);
        } catch (err) {
          showError(`L·ªói x·ª≠ l√Ω ${file.name}: ${err.message}`);
        }
      }

      function displayResult(original, compressed, stats) {
        const card = document.createElement("div");
        card.className = "result-card";

        const originalUrl = URL.createObjectURL(original);
        const compressedUrl = URL.createObjectURL(compressed);

        card.innerHTML = `
        <h3>‚úÖ ${original.name}</h3>
        
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 15px;">
          <div>
            <p style="text-align: center; color: #666; font-size: 0.9em; margin-bottom: 5px;">·∫¢nh g·ªëc</p>
            <img src="${originalUrl}" class="image-preview" alt="Original">
          </div>
          <div>
            <p style="text-align: center; color: #667eea; font-size: 0.9em; margin-bottom: 5px;">ƒê√£ n√©n</p>
            <img src="${compressedUrl}" class="image-preview" alt="Compressed">
          </div>
        </div>

        <div class="stats">
          <div class="stat-row">
            <span class="stat-label">üì¶ Dung l∆∞·ª£ng g·ªëc:</span>
            <span class="stat-value">${stats.originalSizeKB}</span>
          </div>
          <div class="stat-row">
            <span class="stat-label">‚ú® Sau khi n√©n:</span>
            <span class="stat-value">${stats.compressedSizeKB}</span>
          </div>
          <div class="stat-row">
            <span class="stat-label">üí∞ Ti·∫øt ki·ªám:</span>
            <span class="stat-value savings">${stats.compressionRatio}</span>
          </div>
        </div>

        <button class="download-btn" onclick="downloadImage('${compressedUrl}', '${original.name}')">
          ‚¨áÔ∏è T·∫£i xu·ªëng ·∫£nh ƒë√£ n√©n
        </button>
      `;

        results.appendChild(card);
      }

      function downloadImage(url, originalName) {
        const a = document.createElement("a");
        a.href = url;
        a.download = "compressed_" + originalName;
        a.click();
      }

      function showError(message) {
        error.textContent = "‚ùå " + message;
        error.style.display = "block";
      }

      // Make downloadImage global
      window.downloadImage = downloadImage;
    </script>
  </body>
</html>
